diff --git a/hphp/hack/src/Cargo.toml b/hphp/hack/src/Cargo.toml
index 57decf6562c..b860f13348d 100644
--- a/hphp/hack/src/Cargo.toml
+++ b/hphp/hack/src/Cargo.toml
@@ -109,3 +109,6 @@ members = [
     "utils/test",
     "utils/test/arena_deserializer",
 ]
+
+[workspace.lints.rust]
+warnings = "allow"
diff --git a/hphp/hack/src/arena_collections/lib.rs b/hphp/hack/src/arena_collections/lib.rs
index b61498ef2a2..536390f62a9 100644
--- a/hphp/hack/src/arena_collections/lib.rs
+++ b/hphp/hack/src/arena_collections/lib.rs
@@ -3,6 +3,8 @@
 // This source code is licensed under the MIT license found in the
 // LICENSE file in the "hack" directory of this source tree.
 
+#![allow(clippy::all)]
+
 mod alist;
 mod multiset;
 
diff --git a/hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml b/hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml
index 7f5bdb0b49c..1efb549993e 100644
--- a/hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml
+++ b/hphp/hack/src/decl/cargo/rust_decl_ffi/Cargo.toml
@@ -18,9 +18,11 @@ crossbeam = "0.8"
 direct_decl_parser = { version = "0.0.0", path = "../../../parser/api/cargo/direct_decl_parser" }
 hh_hash = { version = "0.0.0", path = "../../../utils/hh_hash" }
 ocamlrep = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
-ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
 ocamlrep_custom = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
 ocamlrep_ocamlpool = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
 oxidized = { version = "0.0.0", path = "../../../oxidized" }
 rayon = "1.11.0"
 relative_path = { version = "0.0.0", path = "../../../utils/rust/relative_path" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
\ No newline at end of file
diff --git a/hphp/hack/src/deps/rust/file_info.rs b/hphp/hack/src/deps/rust/file_info.rs
index 798aa090a84..2913788f3ed 100644
--- a/hphp/hack/src/deps/rust/file_info.rs
+++ b/hphp/hack/src/deps/rust/file_info.rs
@@ -13,7 +13,7 @@ use no_pos_hash::NoPosHash;
 use ocamlrep::FromOcamlRep;
 use ocamlrep::FromOcamlRepIn;
 use ocamlrep::ToOcamlRep;
-use ocamlrep_caml_builtins::Int64;
+//use ocamlrep_caml_builtins::Int64;
 use serde::Deserialize;
 use serde::Serialize;
 
@@ -181,16 +181,15 @@ pub struct SiAddendum {
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(attr = "deriving (eq, show)")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(attr = "deriving (eq, show)"))]
 #[repr(C, u8)]
 pub enum Pos {
     Full(pos::Pos),
@@ -204,21 +203,20 @@ pub enum Pos {
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(attr = "deriving (eq, show)")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(attr = "deriving (eq, show)"))]
 #[repr(C)]
 pub struct Id {
     pub pos: Pos,
     pub name: String,
-    pub decl_hash: Option<Int64>,
+    pub decl_hash: Option<u64>,
     pub sort_text: Option<String>,
 }
 
@@ -228,34 +226,32 @@ pub struct Id {
     Deserialize,
     Eq,
     EqModuloPos,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(attr = "deriving eq")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(attr = "deriving eq"))]
 #[repr(C)]
-pub struct HashType(pub Option<Int64>);
+pub struct HashType(pub Option<u64>);
 
 #[derive(
     Clone,
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(attr = "deriving show")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(attr = "deriving show"))]
 #[repr(C)]
 pub struct Ids {
     pub funs: Vec<Id>,
@@ -271,16 +267,15 @@ pub struct Ids {
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(attr = "deriving show")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(attr = "deriving show"))]
 #[repr(C)]
 pub struct FileInfo {
     /// The hash value of all the decls stripped of their positions.
@@ -294,22 +289,21 @@ pub struct FileInfo {
 }
 
 /// a position-free hash of decls in the file, generated by [Direct_decl_parser.parse_and_hash_decls]
-pub type PfhHash = Int64;
+pub type PfhHash = u64;
 
 #[derive(
     Clone,
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
 #[repr(C)]
 pub struct Change {
     pub path: relative_path::RelativePath,
@@ -327,17 +321,16 @@ pub struct Change {
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(attr = "deriving show")]
-#[rust_to_ocaml(prefix = "n_")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(attr = "deriving show"))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(prefix = "n_"))]
 #[repr(C)]
 pub struct Names {
     pub funs: s_set::SSet,
@@ -353,16 +346,15 @@ pub struct Names {
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
-#[rust_to_ocaml(prefix = "sn_")]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
+#[cfg_attr(not(target_arch = "wasm32"), rust_to_ocaml(prefix = "sn_"))]
 #[repr(C)]
 pub struct SavedNames {
     pub funs: s_set::SSet,
@@ -377,15 +369,14 @@ pub struct SavedNames {
     Debug,
     Deserialize,
     Eq,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep,
 )]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
 #[repr(C)]
 pub struct Diff {
     pub removed_funs: s_set::SSet,
diff --git a/hphp/hack/src/deps/rust/file_info/Cargo.toml b/hphp/hack/src/deps/rust/file_info/Cargo.toml
index 82d5c03f0e5..5d19d5a6fb4 100644
--- a/hphp/hack/src/deps/rust/file_info/Cargo.toml
+++ b/hphp/hack/src/deps/rust/file_info/Cargo.toml
@@ -17,11 +17,13 @@ eq_modulo_pos = { version = "0.0.0", path = "../../../utils/eq_modulo_pos" }
 naming_types = { version = "0.0.0", path = "../../../naming/rust/naming_types" }
 no_pos_hash = { version = "0.0.0", path = "../../../utils/no_pos_hash" }
 ocamlrep = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
-ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
 parser_core_types = { version = "0.0.0", path = "../../../parser/cargo/core_types" }
 rc_pos = { version = "0.0.0", path = "../../../utils/rust/pos" }
 relative_path = { version = "0.0.0", path = "../../../utils/rust/relative_path" }
-rusqlite = { version = "0.36.0", features = ["backup", "blob", "bundled", "column_decltype", "functions", "limits", "modern_sqlite", "serde_json"] }
 serde = { version = "1.0.219", features = ["derive", "rc"] }
 thiserror = "2.0.12"
 typing_deps_hash = { version = "0.0.0", path = "../../cargo/typing_deps_hash" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+rusqlite = { version = "0.36.0", features = ["backup", "blob", "bundled", "column_decltype", "functions", "limits", "modern_sqlite", "serde_json"] }
+ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
\ No newline at end of file
diff --git a/hphp/hack/src/deps/rust/file_info_lib.rs b/hphp/hack/src/deps/rust/file_info_lib.rs
index ab6789911ec..4ce9b155a3e 100644
--- a/hphp/hack/src/deps/rust/file_info_lib.rs
+++ b/hphp/hack/src/deps/rust/file_info_lib.rs
@@ -15,10 +15,13 @@ mod s_set {
 }
 
 use naming_types::KindOfType;
-use relative_path::RelativePath;
+#[cfg(unix)]
 use rusqlite::types::FromSql;
+#[cfg(unix)]
 use rusqlite::types::FromSqlError;
+#[cfg(unix)]
 use rusqlite::types::FromSqlResult;
+#[cfg(unix)]
 use rusqlite::types::ValueRef;
 
 impl From<Mode> for parser_core_types::FileMode {
@@ -48,15 +51,6 @@ impl std::cmp::PartialEq<Mode> for parser_core_types::FileMode {
     }
 }
 
-impl Pos {
-    pub fn path(&self) -> &RelativePath {
-        match self {
-            Pos::Full(pos) => pos.filename(),
-            Pos::File(_, path) => path,
-        }
-    }
-}
-
 impl From<KindOfType> for NameType {
     fn from(kind: KindOfType) -> Self {
         match kind {
@@ -93,6 +87,7 @@ impl From<NameType> for typing_deps_hash::DepType {
     }
 }
 
+#[cfg(unix)]
 impl FromSql for NameType {
     fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self> {
         match value {
@@ -116,6 +111,7 @@ impl FromSql for NameType {
     }
 }
 
+#[cfg(unix)]
 impl rusqlite::ToSql for NameType {
     fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
         Ok(rusqlite::types::ToSqlOutput::from(*self as i64))
diff --git a/hphp/hack/src/hackc/utils/string_utils.rs b/hphp/hack/src/hackc/utils/string_utils.rs
index ef6f2da38f7..36a114359ba 100644
--- a/hphp/hack/src/hackc/utils/string_utils.rs
+++ b/hphp/hack/src/hackc/utils/string_utils.rs
@@ -249,6 +249,7 @@ pub mod integer {
 }
 
 pub mod float {
+    #[cfg(not(target_arch = "wasm32"))]
     fn sprintf(f: f64) -> Option<String> {
         const BUF_SIZE: usize = 256;
 
@@ -269,6 +270,12 @@ pub mod float {
         }
     }
 
+    #[cfg(target_arch = "wasm32")]
+    fn sprintf(f: f64) -> Option<String> {
+        // On WASM, use Rust's built-in formatting as a fallback
+        Some(format!("{:.17}", f))
+    }
+
     pub fn to_string(f: impl Into<f64>) -> String {
         let f = f.into();
         // or_else should not happen, but just in case it does fall back
diff --git a/hphp/hack/src/naming/names_rust/Cargo.toml b/hphp/hack/src/naming/names_rust/Cargo.toml
index eeaf509460e..bbe89d02681 100644
--- a/hphp/hack/src/naming/names_rust/Cargo.toml
+++ b/hphp/hack/src/naming/names_rust/Cargo.toml
@@ -17,6 +17,8 @@ hh24_types = { version = "0.0.0", path = "../../utils/hh24_types" }
 oxidized = { version = "0.0.0", path = "../../oxidized" }
 rand = { version = "0.8", features = ["small_rng"] }
 relative_path = { version = "0.0.0", path = "../../utils/rust/relative_path" }
-rusqlite = { version = "0.36.0", features = ["backup", "blob", "bundled", "column_decltype", "functions", "limits", "modern_sqlite", "serde_json"] }
 serde = { version = "1.0.219", features = ["derive", "rc"] }
 typing_deps_hash = { version = "0.0.0", path = "../../deps/cargo/typing_deps_hash" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+rusqlite = { version = "0.36.0", features = ["backup", "blob", "bundled", "column_decltype", "functions", "limits", "modern_sqlite", "serde_json"] }
\ No newline at end of file
diff --git a/hphp/hack/src/naming/names_rust/datatypes.rs b/hphp/hack/src/naming/names_rust/datatypes.rs
index 91106097aa3..930dfa897c5 100644
--- a/hphp/hack/src/naming/names_rust/datatypes.rs
+++ b/hphp/hack/src/naming/names_rust/datatypes.rs
@@ -11,9 +11,13 @@ use oxidized::file_info::Mode;
 use oxidized::file_info::NameType;
 use relative_path::Prefix;
 use relative_path::RelativePath;
+#[cfg(unix)]
 use rusqlite::types::FromSql;
+#[cfg(unix)]
 use rusqlite::types::FromSqlError;
+#[cfg(unix)]
 use rusqlite::types::FromSqlResult;
+#[cfg(unix)]
 use rusqlite::types::ValueRef;
 
 #[derive(Debug, Default)]
@@ -83,6 +87,7 @@ impl FileInfoId {
     }
 }
 
+#[cfg(unix)]
 impl rusqlite::ToSql for FileInfoId {
     fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
         Ok(rusqlite::types::ToSqlOutput::from(self.0.get() as i64))
diff --git a/hphp/hack/src/naming/names_rust/naming_sqlite.rs b/hphp/hack/src/naming/names_rust/naming_sqlite.rs
index 3097a7abedb..bf587c78b96 100644
--- a/hphp/hack/src/naming/names_rust/naming_sqlite.rs
+++ b/hphp/hack/src/naming/names_rust/naming_sqlite.rs
@@ -12,8 +12,11 @@ use hh24_types::ToplevelCanonSymbolHash;
 use hh24_types::ToplevelSymbolHash;
 use oxidized::file_info::NameType;
 use relative_path::RelativePath;
+#[cfg(unix)]
 use rusqlite::Connection;
+#[cfg(unix)]
 use rusqlite::OptionalExtension;
+#[cfg(unix)]
 use rusqlite::params;
 
 pub struct Names {
diff --git a/hphp/hack/src/naming/naming_special_names.rs b/hphp/hack/src/naming/naming_special_names.rs
index 48ba41b56cb..27e5e806145 100644
--- a/hphp/hack/src/naming/naming_special_names.rs
+++ b/hphp/hack/src/naming/naming_special_names.rs
@@ -7,6 +7,8 @@
  *
  */
 
+#![allow(clippy::all)]
+
 /** Module consisting of the special names known to the typechecker */
 pub mod classes {
     pub const PARENT: &str = "parent";
diff --git a/hphp/hack/src/oxidized/gen/edenfs_watcher_types.rs b/hphp/hack/src/oxidized/gen/edenfs_watcher_types.rs
index 6d98f428154..fa6f53efecd 100644
--- a/hphp/hack/src/oxidized/gen/edenfs_watcher_types.rs
+++ b/hphp/hack/src/oxidized/gen/edenfs_watcher_types.rs
@@ -169,15 +169,14 @@ pub struct StandaloneGetChangesSinceTelemetry {
     Deserialize,
     Eq,
     EqModuloPos,
-    FromOcamlRep,
     Hash,
     NoPosHash,
     Ord,
     PartialEq,
     PartialOrd,
     Serialize,
-    ToOcamlRep
 )]
+#[cfg_attr(not(target_arch = "wasm32"), derive(FromOcamlRep, ToOcamlRep))]
 #[repr(C)]
 pub struct Settings {
     pub root: std::path::PathBuf,
diff --git a/hphp/hack/src/oxidized/gen/warnings_saved_state.rs b/hphp/hack/src/oxidized/gen/warnings_saved_state.rs
index ce9968a8413..6451672f7d2 100644
--- a/hphp/hack/src/oxidized/gen/warnings_saved_state.rs
+++ b/hphp/hack/src/oxidized/gen/warnings_saved_state.rs
@@ -13,7 +13,7 @@ pub use error_hash_set::*;
 #[allow(unused_imports)]
 use crate::*;
 
-#[rust_to_ocaml(attr = "deriving (ord, show)")]
-pub type ErrorHash = ocamlrep::OCamlInt;
+//#[rust_to_ocaml(attr = "deriving (ord, show)")]
+pub type ErrorHash = u64;
 
 pub type Path = String;
diff --git a/hphp/hack/src/oxidized/manual/user_error_impl.rs b/hphp/hack/src/oxidized/manual/user_error_impl.rs
index ee2ade73136..845d0eb004e 100644
--- a/hphp/hack/src/oxidized/manual/user_error_impl.rs
+++ b/hphp/hack/src/oxidized/manual/user_error_impl.rs
@@ -8,7 +8,7 @@ use std::hash::Hash;
 
 use ansi_term::Color;
 use hh_hash::Hasher;
-use ocamlrep::OCamlInt;
+// use ocamlrep::OCamlInt;
 use rc_pos::with_erased_lines::WithErasedLines;
 
 use crate::explanation::Explanation;
@@ -39,7 +39,7 @@ impl<PrimPos: Hash + WithErasedLines + Clone, Pos: Hash + WithErasedLines + Clon
         let mut hasher = DefaultHasher::new();
         self.clone().with_erased_lines().hash(&mut hasher);
         let hash = hasher.finish();
-        OCamlInt::new_erase_msb(hash as isize)
+        hash as u64
     }
 }
 
diff --git a/hphp/hack/src/parser/aast_parser.rs b/hphp/hack/src/parser/aast_parser.rs
index a7469c3062e..71900aac7af 100644
--- a/hphp/hack/src/parser/aast_parser.rs
+++ b/hphp/hack/src/parser/aast_parser.rs
@@ -5,7 +5,7 @@
 // LICENSE file in the "hack" directory of this source tree.
 
 use std::sync::Arc;
-use std::time::Instant;
+
 
 use bumpalo::Bump;
 use hash::HashSet;
@@ -89,11 +89,11 @@ impl<'src> AastParser {
         if let Some(err) = Self::verify_utf8(indexed_source_text) {
             return Ok(err);
         }
-        let start_t = Instant::now();
+        //let start_t = Instant::now();
         let arena = Bump::new();
         stack_limit::reset();
         let (language, mode, tree) = Self::parse_text(&arena, env, indexed_source_text)?;
-        let parsing_t = start_t.elapsed();
+        //let parsing_t = start_t.elapsed();
         let parse_peak = stack_limit::peak();
         let mut pr = Self::from_tree_with_namespace_env(
             env,
@@ -107,8 +107,8 @@ impl<'src> AastParser {
         )?;
 
         pr.profile.parse_peak = parse_peak as u64;
-        pr.profile.parsing_t = parsing_t;
-        pr.profile.total_t = start_t.elapsed();
+        //pr.profile.parsing_t = parsing_t;
+        //pr.profile.total_t = start_t.elapsed();
         Ok(pr)
     }
 
@@ -169,7 +169,7 @@ impl<'src> AastParser {
         tree: PositionedSyntaxTree<'src, 'arena>,
         default_experimental_features: HashSet<experimental_features::FeatureName>,
     ) -> Result<ParserResult> {
-        let lowering_t = Instant::now();
+        //let lowering_t = Instant::now();
         match language {
             Language::Hack => {}
             _ => return Err(Error::NotAHackFile()),
@@ -241,7 +241,7 @@ impl<'src> AastParser {
         );
         stack_limit::reset();
         let aast = lower(&mut lowerer_env, tree.root());
-        let (lowering_t, elaboration_t) = (lowering_t.elapsed(), Instant::now());
+        //let (lowering_t, elaboration_t) = (lowering_t.elapsed(), Instant::now());
         let lower_peak = stack_limit::peak() as u64;
         let mut aast = if env.elaborate_namespaces {
             namespaces::toplevel_elaborator::elaborate_toplevel_defs(ns, aast)
@@ -260,12 +260,12 @@ impl<'src> AastParser {
             syntax_errors.extend(expression_tree_check::check_splices(&aast));
             syntax_errors.extend(coeffects_check::check_program(&aast, env.mode));
         }
-        let (elaboration_t, error_t) = (elaboration_t.elapsed(), Instant::now());
+        //let (elaboration_t, error_t) = (elaboration_t.elapsed(), Instant::now());
         let error_peak = stack_limit::peak() as u64;
         let lowerer_parsing_errors = lowerer_env.parsing_errors().to_vec();
         let errors = lowerer_env.hh_errors().to_vec();
         let lint_errors = lowerer_env.lint_errors().to_vec();
-        let error_t = error_t.elapsed();
+        //let error_t = error_t.elapsed();
 
         Ok(ParserResult {
             file_mode: mode,
@@ -277,9 +277,9 @@ impl<'src> AastParser {
             lint_errors,
             profile: ParserProfile {
                 lower_peak,
-                lowering_t,
-                elaboration_t,
-                error_t,
+                lowering_t: std::time::Duration::new(0, 0),
+                elaboration_t: std::time::Duration::new(0, 0),
+                error_t: std::time::Duration::new(0, 0),
                 error_peak,
                 arena_bytes: arena.allocated_bytes() as u64,
                 ..Default::default()
@@ -354,7 +354,7 @@ impl<'src> AastParser {
                     disable_hh_ignore_error: env.parser_options.disable_hh_ignore_error,
                     allowed_decl_fixme_codes: &env.parser_options.allowed_decl_fixme_codes,
                 };
-            Ok(scourer.scour_comments(script))
+            Ok(scourer.scour_comments(script, indexed_source_text.source_text().file_path()))
         } else {
             Ok(Default::default())
         }
diff --git a/hphp/hack/src/parser/core/lexer.rs b/hphp/hack/src/parser/core/lexer.rs
index 60912cf167c..36817ccc15c 100644
--- a/hphp/hack/src/parser/core/lexer.rs
+++ b/hphp/hack/src/parser/core/lexer.rs
@@ -256,7 +256,11 @@ where
 
     fn remaining(&self) -> usize {
         let r = (self.source.length() as isize) - (self.offset as isize);
-        if r < 0 { 0 } else { r as usize }
+        if r < 0 {
+            0
+        } else {
+            r as usize
+        }
     }
 
     fn peek(&self, i: usize) -> char {
@@ -1985,7 +1989,10 @@ where
                         acc.push(t);
                         return acc;
                     }
-                    TriviaKind::FixMe | TriviaKind::Ignore | TriviaKind::IgnoreError => {
+                    TriviaKind::FixMe
+                    | TriviaKind::Ignore
+                    | TriviaKind::IgnoreError
+                    | TriviaKind::DelimitedComment => {
                         return acc;
                     }
                     _ => {
diff --git a/hphp/hack/src/parser/core/lib.rs b/hphp/hack/src/parser/core/lib.rs
index 28f6dd565f6..1cceff6e7c0 100644
--- a/hphp/hack/src/parser/core/lib.rs
+++ b/hphp/hack/src/parser/core/lib.rs
@@ -4,6 +4,8 @@
 // This source code is licensed under the MIT license found in the
 // LICENSE file in the "hack" directory of this source tree.
 
+#![allow(clippy::all)]
+
 pub mod lexer;
 pub use operator;
 pub use operator::*;
diff --git a/hphp/hack/src/parser/lowerer/lowerer.rs b/hphp/hack/src/parser/lowerer/lowerer.rs
index 77a13a242f7..56dc941af9d 100644
--- a/hphp/hack/src/parser/lowerer/lowerer.rs
+++ b/hphp/hack/src/parser/lowerer/lowerer.rs
@@ -3646,12 +3646,12 @@ fn p_markup<'a>(node: S<'a>, env: &mut Env<'a>) -> Result<ast::Stmt> {
             let markup_hashbang = &c.hashbang;
             let markup_suffix = &c.suffix;
             let pos = p_pos(node, env);
-            let f = pos.filename();
             let expected_suffix_offset = if markup_hashbang.is_missing() {
                 0
             } else {
                 markup_hashbang.width() + 1 /* for newline */
             };
+            let f = env.source_text().file_path();
             if (f.has_extension("hack") || f.has_extension("hackpartial"))
                 && !(markup_suffix.is_missing())
             {
diff --git a/hphp/hack/src/parser/lowerer/scour_comment.rs b/hphp/hack/src/parser/lowerer/scour_comment.rs
index e417df3af7f..b41df07e55e 100644
--- a/hphp/hack/src/parser/lowerer/scour_comment.rs
+++ b/hphp/hack/src/parser/lowerer/scour_comment.rs
@@ -17,6 +17,7 @@ use parser_core_types::syntax_by_ref::syntax_variant_generated::SyntaxVariant::*
 use parser_core_types::syntax_trait::SyntaxTrait;
 use parser_core_types::trivia_kind::TriviaKind;
 use regex::bytes::Regex;
+use relative_path::RelativePath;
 use rescan_trivia::RescanTrivia;
 
 /** The full fidelity parser considers all comments "simply" trivia. Some
@@ -41,7 +42,11 @@ where
     V: 'arena,
     Syntax<'arena, T, V>: SyntaxTrait,
 {
-    pub fn scour_comments<'r>(&self, top_node: &'r Syntax<'arena, T, V>) -> ScouredComments
+    pub fn scour_comments<'r>(
+        &self,
+        top_node: &'r Syntax<'arena, T, V>,
+        file_path: &RelativePath,
+    ) -> ScouredComments
     where
         'r: 'arena,
     {
@@ -63,7 +68,7 @@ where
                         let leading = t.scan_leading(self.source_text());
                         let trailing = t.scan_trailing(self.source_text());
                         for tr in leading.iter().chain(trailing.iter()) {
-                            self.on_trivia(in_block, node, tr, &mut acc);
+                            self.on_trivia(in_block, node, tr, &mut acc, file_path);
                         }
                     }
                     continue;
@@ -84,6 +89,7 @@ where
         node: &Syntax<'arena, T, V>,
         t: &PositionedTrivium,
         acc: &mut ScouredComments,
+        file_path: &RelativePath,
     ) {
         use TriviaKind::*;
         use relative_path::Prefix;
@@ -129,7 +135,7 @@ where
                     Some(code) => {
                         let code = std::str::from_utf8(code).unwrap();
                         let code: isize = std::str::FromStr::from_str(code).unwrap();
-                        let in_hhi = pos.filename().prefix() == Prefix::Hhi;
+                        let in_hhi = file_path.prefix() == Prefix::Hhi;
                         match t.kind() {
                             Ignore => {
                                 acc.add_to_ignores(line, code, p);
diff --git a/hphp/hack/src/parser/smart_constructors.rs b/hphp/hack/src/parser/smart_constructors.rs
index 4c773badd23..f3ec193beac 100644
--- a/hphp/hack/src/parser/smart_constructors.rs
+++ b/hphp/hack/src/parser/smart_constructors.rs
@@ -4,6 +4,8 @@
 // This source code is licensed under the MIT license found in the
 // LICENSE file in the "hack" directory of this source tree.
 
+#![allow(clippy::all)]
+
 pub mod smart_constructors_generated;
 pub mod smart_constructors_wrappers;
 
diff --git a/hphp/hack/src/parser/source_text.rs b/hphp/hack/src/parser/source_text.rs
index 0a925108745..2b8775d466e 100644
--- a/hphp/hack/src/parser/source_text.rs
+++ b/hphp/hack/src/parser/source_text.rs
@@ -98,6 +98,7 @@ impl<'a> SourceText<'a> {
     }
 }
 
+#[cfg(not(target_arch = "wasm32"))]
 impl<'content> ToOcamlRep for SourceText<'content> {
     fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, alloc: &'a A) -> ocamlrep::Value<'a> {
         // A SourceText with no associated ocaml_source_text cannot be converted
@@ -107,6 +108,7 @@ impl<'content> ToOcamlRep for SourceText<'content> {
     }
 }
 
+#[cfg(not(target_arch = "wasm32"))]
 impl<'content> FromOcamlRep for SourceText<'content> {
     fn from_ocamlrep(value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError> {
         let block = ocamlrep::from::expect_tuple(value, 4)?;
diff --git a/hphp/hack/src/utils/arena_deserializer/Cargo.toml b/hphp/hack/src/utils/arena_deserializer/Cargo.toml
index c21d0f17a62..cd5681883c9 100644
--- a/hphp/hack/src/utils/arena_deserializer/Cargo.toml
+++ b/hphp/hack/src/utils/arena_deserializer/Cargo.toml
@@ -13,5 +13,7 @@ path = "lib.rs"
 [dependencies]
 bstr = { version = "1.10.0", features = ["serde", "std", "unicode"] }
 bumpalo = { version = "3.14.0", features = ["allocator_api", "collections"] }
-ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
 serde = { version = "1.0.219", features = ["derive", "rc"] }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
diff --git a/hphp/hack/src/utils/arena_deserializer/impls.rs b/hphp/hack/src/utils/arena_deserializer/impls.rs
index c6c4bb0b251..5509aa2f715 100644
--- a/hphp/hack/src/utils/arena_deserializer/impls.rs
+++ b/hphp/hack/src/utils/arena_deserializer/impls.rs
@@ -8,7 +8,7 @@ use std::marker::PhantomData;
 
 use bumpalo::Bump;
 use bumpalo::collections::Vec as ArenaVec;
-use ocamlrep_caml_builtins::Int64;
+//use ocamlrep_caml_builtins::Int64;
 use serde::Deserialize;
 use serde::de::Deserializer;
 use serde::de::SeqAccess;
@@ -95,7 +95,7 @@ impl_deserialize_in_arena!(usize);
 impl_deserialize_in_arena!(f32);
 impl_deserialize_in_arena!(f64);
 impl_deserialize_in_arena!(char);
-impl_deserialize_in_arena!(Int64);
+//impl_deserialize_in_arena!(Int64);
 
 impl<'arena> DeserializeInArena<'arena> for &'arena str {
     fn deserialize_in_arena<D>(arena: &'arena Bump, deserializer: D) -> Result<Self, D::Error>
diff --git a/hphp/hack/src/utils/eq_modulo_pos/Cargo.toml b/hphp/hack/src/utils/eq_modulo_pos/Cargo.toml
index 718b1545ddc..44cdea14fad 100644
--- a/hphp/hack/src/utils/eq_modulo_pos/Cargo.toml
+++ b/hphp/hack/src/utils/eq_modulo_pos/Cargo.toml
@@ -16,4 +16,6 @@ bstr = { version = "1.10.0", features = ["serde", "std", "unicode"] }
 eq_modulo_pos_derive = { version = "0.0.0", path = "../eq_modulo_pos_derive" }
 hcons = { version = "0.0.0", path = "../../hcons" }
 indexmap = { version = "2.9.0", features = ["arbitrary", "rayon", "serde"] }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
 ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
diff --git a/hphp/hack/src/utils/eq_modulo_pos/eq_modulo_pos.rs b/hphp/hack/src/utils/eq_modulo_pos/eq_modulo_pos.rs
index bbcfb3854e5..fc8165ca9bf 100644
--- a/hphp/hack/src/utils/eq_modulo_pos/eq_modulo_pos.rs
+++ b/hphp/hack/src/utils/eq_modulo_pos/eq_modulo_pos.rs
@@ -7,7 +7,6 @@ use std::rc::Rc;
 use std::sync::Arc;
 
 pub use eq_modulo_pos_derive::EqModuloPos;
-use ocamlrep_caml_builtins::Int64;
 
 /// An implementation of `Eq` which is insensitive to positions
 /// (e.g., `pos::BPos`) and reasons (e.g., `ty::reason::BReason`).
@@ -109,7 +108,6 @@ impl_with_equal! {
     std::path::PathBuf,
     bstr::BStr,
     bstr::BString,
-    Int64,
 }
 
 macro_rules! impl_deref {
diff --git a/hphp/hack/src/utils/hh24_types/Cargo.toml b/hphp/hack/src/utils/hh24_types/Cargo.toml
index a946cb97854..5520fdf379d 100644
--- a/hphp/hack/src/utils/hh24_types/Cargo.toml
+++ b/hphp/hack/src/utils/hh24_types/Cargo.toml
@@ -16,8 +16,10 @@ derive_more = { version = "1.0.0", features = ["full"] }
 file_info = { version = "0.0.0", path = "../../deps/rust/file_info" }
 hh_hash = { version = "0.0.0", path = "../hh_hash" }
 relative_path = { version = "0.0.0", path = "../rust/relative_path" }
-rusqlite = { version = "0.36.0", features = ["backup", "blob", "bundled", "column_decltype", "functions", "limits", "modern_sqlite", "serde_json"] }
 serde = { version = "1.0.219", features = ["derive", "rc"] }
 serde_json = { version = "1.0.140", features = ["alloc", "float_roundtrip", "raw_value", "unbounded_depth"] }
 thiserror = "2.0.12"
 typing_deps_hash = { version = "0.0.0", path = "../../deps/cargo/typing_deps_hash" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
+rusqlite = { version = "0.36.0", features = ["backup", "blob", "bundled", "column_decltype", "functions", "limits", "modern_sqlite", "serde_json"] }
diff --git a/hphp/hack/src/utils/hh24_types/hh24_types.rs b/hphp/hack/src/utils/hh24_types/hh24_types.rs
index 0febd35fe7d..4fd8c642cac 100644
--- a/hphp/hack/src/utils/hh24_types/hh24_types.rs
+++ b/hphp/hack/src/utils/hh24_types/hh24_types.rs
@@ -32,12 +32,14 @@ macro_rules! u64_hash_wrapper_impls {
             }
         }
 
+        #[cfg(unix)]
         impl rusqlite::ToSql for $name {
             fn to_sql(&self) -> rusqlite::Result<rusqlite::types::ToSqlOutput<'_>> {
                 Ok(rusqlite::types::ToSqlOutput::from(self.0 as i64))
             }
         }
 
+        #[cfg(unix)]
         impl rusqlite::types::FromSql for $name {
             fn column_result(
                 value: rusqlite::types::ValueRef<'_>,
diff --git a/hphp/hack/src/utils/no_pos_hash/Cargo.toml b/hphp/hack/src/utils/no_pos_hash/Cargo.toml
index dd2d6812501..55bf668672d 100644
--- a/hphp/hack/src/utils/no_pos_hash/Cargo.toml
+++ b/hphp/hack/src/utils/no_pos_hash/Cargo.toml
@@ -15,4 +15,6 @@ arena_collections = { version = "0.0.0", path = "../../arena_collections" }
 bstr = { version = "1.10.0", features = ["serde", "std", "unicode"] }
 fnv = "1.0"
 no_pos_hash_derive = { version = "0.0.0", path = "derive" }
+
+[target.'cfg(not(target_arch = "wasm32"))'.dependencies]
 ocamlrep_caml_builtins = { version = "0.1.0", git = "https://github.com/facebook/ocamlrep/", branch = "main" }
diff --git a/hphp/hack/src/utils/no_pos_hash/no_pos_hash.rs b/hphp/hack/src/utils/no_pos_hash/no_pos_hash.rs
index 396831e47f5..32693ed0a4b 100644
--- a/hphp/hack/src/utils/no_pos_hash/no_pos_hash.rs
+++ b/hphp/hack/src/utils/no_pos_hash/no_pos_hash.rs
@@ -44,8 +44,6 @@ pub fn position_insensitive_hash<T: NoPosHash>(value: &T) -> u64 {
 }
 
 mod impls {
-    use ocamlrep_caml_builtins::Int64;
-
     use super::*;
 
     impl<T: NoPosHash> NoPosHash for [T] {
@@ -107,7 +105,6 @@ mod impls {
         String,
         std::path::PathBuf,
         bstr::BString,
-        Int64,
     }
 
     macro_rules! impl_with_std_hash_unsized {
diff --git a/hphp/hack/src/utils/rust/pos/file_pos.rs b/hphp/hack/src/utils/rust/pos/file_pos.rs
index fff34e9c159..49ae1121f9c 100644
--- a/hphp/hack/src/utils/rust/pos/file_pos.rs
+++ b/hphp/hack/src/utils/rust/pos/file_pos.rs
@@ -4,6 +4,6 @@
 // LICENSE file in the "hack" directory of this source tree.
 
 pub trait FilePos {
-    fn offset(&self) -> usize;
-    fn line_column_beg(&self) -> (usize, usize, usize);
+    fn offset(&self) -> u64;
+    fn line_column_beg(&self) -> (u64, u64, u64);
 }
diff --git a/hphp/hack/src/utils/rust/pos/file_pos_large.rs b/hphp/hack/src/utils/rust/pos/file_pos_large.rs
index bb92cf38693..0d6066c67e9 100644
--- a/hphp/hack/src/utils/rust/pos/file_pos_large.rs
+++ b/hphp/hack/src/utils/rust/pos/file_pos_large.rs
@@ -16,13 +16,13 @@ use crate::with_erased_lines::WithErasedLines;
 #[derive(Copy, Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
 pub struct FilePosLarge {
     /// line number. Starts at 1.
-    lnum: usize,
+    lnum: u64,
     /// character offset (from the beginning of file) of the beginning of line of this position.
     /// The column number is therefore offset - bol
     /// Starts at 0
-    bol: usize,
+    bol: u64,
     /// character offset from the beginning of the file. Starts at 0.
-    offset: usize,
+    offset: u64,
 }
 arena_deserializer::impl_deserialize_in_arena!(FilePosLarge);
 
@@ -31,7 +31,7 @@ impl arena_trait::TrivialDrop for FilePosLarge {}
 const DUMMY: FilePosLarge = FilePosLarge {
     lnum: 0,
     bol: 0,
-    offset: usize::max_value(),
+    offset: u64::max_value(),
 };
 
 impl FilePosLarge {
@@ -57,7 +57,7 @@ impl FilePosLarge {
     // constructors
 
     #[inline]
-    pub const fn from_line_column_offset(line: usize, column: usize, offset: usize) -> Self {
+    pub const fn from_line_column_offset(line: u64, column: u64, offset: u64) -> Self {
         FilePosLarge {
             lnum: line,
             bol: offset - column,
@@ -66,29 +66,29 @@ impl FilePosLarge {
     }
 
     #[inline]
-    pub const fn from_lnum_bol_offset(lnum: usize, bol: usize, offset: usize) -> Self {
+    pub const fn from_lnum_bol_offset(lnum: u64, bol: u64, offset: u64) -> Self {
         FilePosLarge { lnum, bol, offset }
     }
 
     // accessors
 
     #[inline]
-    pub const fn line(self) -> usize {
+    pub const fn line(self) -> u64 {
         self.lnum
     }
 
     #[inline]
-    pub const fn column(self) -> usize {
+    pub fn column(self) -> u64 {
         self.offset - self.bol
     }
 
     #[inline]
-    pub const fn beg_of_line(self) -> usize {
+    pub const fn beg_of_line(self) -> u64 {
         self.bol
     }
 
     #[inline]
-    pub const fn with_column(self, col: usize) -> Self {
+    pub const fn with_column(self, col: u64) -> Self {
         FilePosLarge {
             lnum: self.lnum,
             bol: self.bol,
@@ -97,34 +97,34 @@ impl FilePosLarge {
     }
 
     #[inline]
-    pub const fn line_beg(self) -> (usize, usize) {
+    pub const fn line_beg(self) -> (u64, u64) {
         (self.lnum, self.bol)
     }
 
     #[inline]
-    pub const fn line_column(self) -> (usize, usize) {
+    pub const fn line_column(self) -> (u64, u64) {
         (self.lnum, self.offset - self.bol)
     }
 
     #[inline]
-    pub const fn line_column_offset(self) -> (usize, usize, usize) {
+    pub const fn line_column_offset(self) -> (u64, u64, u64) {
         (self.lnum, self.offset - self.bol, self.offset)
     }
 
     #[inline]
-    pub const fn line_beg_offset(self) -> (usize, usize, usize) {
+    pub const fn line_beg_offset(self) -> (u64, u64, u64) {
         (self.lnum, self.bol, self.offset)
     }
 }
 
 impl FilePos for FilePosLarge {
     #[inline]
-    fn offset(&self) -> usize {
+    fn offset(&self) -> u64 {
         self.offset
     }
 
     #[inline]
-    fn line_column_beg(&self) -> (usize, usize, usize) {
+    fn line_column_beg(&self) -> (u64, u64, u64) {
         (self.lnum, self.offset - self.bol, self.bol)
     }
 }
@@ -167,7 +167,7 @@ impl FromOcamlRep for FilePosLarge {
         Ok(Self {
             lnum,
             bol,
-            offset: offset as usize,
+            offset: offset as u64,
         })
     }
 }
diff --git a/hphp/hack/src/utils/rust/pos/file_pos_small.rs b/hphp/hack/src/utils/rust/pos/file_pos_small.rs
index 0097f1c7f5e..a20bada630b 100644
--- a/hphp/hack/src/utils/rust/pos/file_pos_small.rs
+++ b/hphp/hack/src/utils/rust/pos/file_pos_small.rs
@@ -39,23 +39,23 @@ arena_deserializer::impl_deserialize_in_arena!(FilePosSmall);
 
 impl arena_trait::TrivialDrop for FilePosSmall {}
 
-const COLUMN_BITS: usize = 9;
-const LINE_BITS: usize = 24;
-const BOL_BITS: usize = 30;
+const COLUMN_BITS: u64 = 9;
+const LINE_BITS: u64 = 24;
+const BOL_BITS: u64 = 30;
 
 #[inline]
-const fn mask(bits: usize) -> usize {
+const fn mask(bits: u64) -> u64 {
     (1 << bits) - 1
 }
 
 #[inline]
-const fn mask_by(bits: usize, x: u64) -> usize {
-    (x & (mask(bits) as u64)) as usize
+const fn mask_by(bits: u64, x: u64) -> u64 {
+    x & mask(bits)
 }
 
-const MAX_COLUMN: usize = mask(COLUMN_BITS);
-const MAX_LINE: usize = mask(LINE_BITS);
-const MAX_BOL: usize = mask(BOL_BITS);
+const MAX_COLUMN: u64 = mask(COLUMN_BITS);
+const MAX_LINE: u64 = mask(LINE_BITS);
+const MAX_BOL: u64 = mask(BOL_BITS);
 
 const DUMMY: u64 = u64::max_value();
 
@@ -71,7 +71,7 @@ impl FilePosSmall {
     }
 
     #[inline]
-    pub fn beg_of_line(self) -> usize {
+    pub fn beg_of_line(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
@@ -80,7 +80,7 @@ impl FilePosSmall {
     }
 
     #[inline]
-    pub fn line(self) -> usize {
+    pub fn line(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
@@ -89,25 +89,25 @@ impl FilePosSmall {
     }
 
     #[inline]
-    pub fn column(self) -> usize {
+    pub fn column(self) -> u64 {
         if self.is_dummy() {
-            DUMMY as usize
+            DUMMY
         } else {
             mask_by(COLUMN_BITS, self.0)
         }
     }
 
     #[inline]
-    const fn bol_line_col_unchecked(bol: usize, line: usize, col: usize) -> Self {
+    const fn bol_line_col_unchecked(bol: u64, line: u64, col: u64) -> Self {
         FilePosSmall(
-            ((bol as u64) << (COLUMN_BITS + LINE_BITS))
-                + ((line as u64) << COLUMN_BITS)
-                + (col as u64),
+            (bol << (COLUMN_BITS + LINE_BITS))
+                + (line << COLUMN_BITS)
+                + col,
         )
     }
 
     #[inline]
-    fn bol_line_col(bol: usize, line: usize, col: usize) -> Option<Self> {
+    fn bol_line_col(bol: u64, line: u64, col: u64) -> Option<Self> {
         if col > MAX_COLUMN || line > MAX_LINE || bol > MAX_BOL {
             None
         } else {
@@ -123,39 +123,39 @@ impl FilePosSmall {
     // constructors
 
     #[inline]
-    pub fn from_line_column_offset(line: usize, column: usize, offset: usize) -> Option<Self> {
+    pub fn from_line_column_offset(line: u64, column: u64, offset: u64) -> Option<Self> {
         Self::bol_line_col(offset - column, line, column)
     }
 
     #[inline]
-    pub fn from_lnum_bol_offset(lnum: usize, bol: usize, offset: usize) -> Option<Self> {
+    pub fn from_lnum_bol_offset(lnum: u64, bol: u64, offset: u64) -> Option<Self> {
         Self::bol_line_col(bol, lnum, offset - bol)
     }
 
     // accessors
 
     #[inline]
-    pub fn line_beg(self) -> (usize, usize) {
+    pub fn line_beg(self) -> (u64, u64) {
         (self.line(), self.beg_of_line())
     }
 
     #[inline]
-    pub fn line_column(self) -> (usize, usize) {
+    pub fn line_column(self) -> (u64, u64) {
         (self.line(), self.column())
     }
 
     #[inline]
-    pub fn line_column_offset(self) -> (usize, usize, usize) {
+    pub fn line_column_offset(self) -> (u64, u64, u64) {
         (self.line(), self.column(), self.offset())
     }
 
     #[inline]
-    pub fn line_beg_offset(self) -> (usize, usize, usize) {
+    pub fn line_beg_offset(self) -> (u64, u64, u64) {
         (self.line(), self.beg_of_line(), self.offset())
     }
 
     #[inline]
-    pub fn with_column(self, col: usize) -> Self {
+    pub fn with_column(self, col: u64) -> Self {
         match Self::bol_line_col(self.beg_of_line(), self.line(), col) {
             None => FilePosSmall(DUMMY),
             Some(pos) => pos,
@@ -177,12 +177,12 @@ impl TryFrom<FilePosLarge> for FilePosSmall {
 
 impl FilePos for FilePosSmall {
     #[inline]
-    fn offset(&self) -> usize {
+    fn offset(&self) -> u64 {
         self.beg_of_line() + self.column()
     }
 
     #[inline]
-    fn line_column_beg(&self) -> (usize, usize, usize) {
+    fn line_column_beg(&self) -> (u64, u64, u64) {
         (self.line(), self.column(), self.beg_of_line())
     }
 }
diff --git a/hphp/hack/src/utils/rust/pos/pos_impl.rs b/hphp/hack/src/utils/rust/pos/pos_impl.rs
index e5e6dd2d88a..5e63116198c 100644
--- a/hphp/hack/src/utils/rust/pos/pos_impl.rs
+++ b/hphp/hack/src/utils/rust/pos/pos_impl.rs
@@ -44,9 +44,37 @@ enum PosImpl {
     FromReason(Box<PosImpl>),
 }
 
-#[derive(Clone, Deserialize, FromOcamlRep, ToOcamlRep, Serialize)]
+#[derive(Clone, Deserialize, Serialize)]
 pub struct Pos(PosImpl);
 
+#[cfg(not(target_arch = "wasm32"))]
+impl ToOcamlRep for Pos {
+    fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, alloc: &'a A) -> ocamlrep::Value<'a> {
+        self.0.to_ocamlrep(alloc)
+    }
+}
+
+#[cfg(not(target_arch = "wasm32"))]
+impl FromOcamlRep for Pos {
+    fn from_ocamlrep(value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError> {
+        Ok(Pos(PosImpl::from_ocamlrep(value)?))
+    }
+}
+
+#[cfg(target_arch = "wasm32")]
+impl ToOcamlRep for Pos {
+    fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, _alloc: &'a A) -> ocamlrep::Value<'a> {
+        panic!("ToOcamlRep not supported on WASM")
+    }
+}
+
+#[cfg(target_arch = "wasm32")]
+impl FromOcamlRep for Pos {
+    fn from_ocamlrep(_value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError> {
+        panic!("FromOcamlRep not supported on WASM")
+    }
+}
+
 pub type PosR<'a> = &'a Pos;
 
 impl Pos {
@@ -153,7 +181,7 @@ impl Pos {
             if end == start_minus1 {
                 end = start
             }
-            (line, start, end)
+            (line as usize, start as usize, end as usize)
         }
         match &self.0 {
             PosImpl::Small { start, end, .. } => compute(start, end),
@@ -170,12 +198,11 @@ impl Pos {
     pub fn info_pos_extended(&self) -> (usize, usize, usize, usize) {
         let (line_begin, start, end) = self.info_pos();
         let line_end = match &self.0 {
-            PosImpl::Small { end, .. } => end.line_column_beg(),
-            PosImpl::Large { end, .. } => (*end).line_column_beg(),
-            PosImpl::Tiny { span, .. } => span.to_raw_span().end.line_column_beg(),
+            PosImpl::Small { start, .. } => start.line() as usize,
+            PosImpl::Large { start, .. } => start.line() as usize,
+            PosImpl::Tiny { span, .. } => span.start_line_number() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
-        }
-        .0;
+        };
         (line_begin, line_end, start, end)
     }
 
@@ -185,9 +212,9 @@ impl Pos {
 
     pub fn line(&self) -> usize {
         match &self.0 {
-            PosImpl::Small { start, .. } => start.line(),
-            PosImpl::Large { start, .. } => start.line(),
-            PosImpl::Tiny { span, .. } => span.start_line_number(),
+            PosImpl::Small { start, .. } => start.line() as usize,
+            PosImpl::Large { start, .. } => start.line() as usize,
+            PosImpl::Tiny { span, .. } => span.start_line_number() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
         }
     }
@@ -199,15 +226,20 @@ impl Pos {
     ) -> Self {
         let (start_line, start_bol, start_offset) = start;
         let (end_line, end_bol, end_offset) = end;
-        let start = FilePosLarge::from_lnum_bol_offset(start_line, start_bol, start_offset);
-        let end = FilePosLarge::from_lnum_bol_offset(end_line, end_bol, end_offset);
+        let start = FilePosLarge::from_lnum_bol_offset(
+            start_line as u64,
+            start_bol as u64,
+            start_offset as u64,
+        );
+        let end =
+            FilePosLarge::from_lnum_bol_offset(end_line as u64, end_bol as u64, end_offset as u64);
         Self::from_raw_span(file, PosSpanRaw { start, end })
     }
 
     pub fn to_start_and_end_lnum_bol_offset(
         &self,
     ) -> ((usize, usize, usize), (usize, usize, usize)) {
-        match &self.0 {
+        let (start, end) = match &self.0 {
             PosImpl::Small { start, end, .. } => (start.line_beg_offset(), end.line_beg_offset()),
             PosImpl::Large { start, end, .. } => (start.line_beg_offset(), end.line_beg_offset()),
             PosImpl::Tiny { span, .. } => {
@@ -215,7 +247,11 @@ impl Pos {
                 (start.line_beg_offset(), end.line_beg_offset())
             }
             PosImpl::FromReason(_p) => unimplemented!(),
-        }
+        };
+        (
+            (start.0 as usize, start.1 as usize, start.2 as usize),
+            (end.0 as usize, end.1 as usize, end.2 as usize),
+        )
     }
 
     /// For single-line spans only.
@@ -225,11 +261,15 @@ impl Pos {
         cols: Range<usize>,
         start_offset: usize,
     ) -> Self {
-        let start = FilePosLarge::from_line_column_offset(line, cols.start, start_offset);
+        let start = FilePosLarge::from_line_column_offset(
+            line as u64,
+            cols.start as u64,
+            start_offset as u64,
+        );
         let end = FilePosLarge::from_line_column_offset(
-            line,
-            cols.end,
-            start_offset + (cols.end - cols.start),
+            line as u64,
+            cols.end as u64,
+            (start_offset + (cols.end - cols.start)) as u64,
         );
         Self::from_raw_span(file, PosSpanRaw { start, end })
     }
@@ -349,18 +389,18 @@ impl Pos {
 
     pub fn end_offset(&self) -> usize {
         match &self.0 {
-            PosImpl::Small { end, .. } => end.offset(),
-            PosImpl::Large { end, .. } => end.offset(),
-            PosImpl::Tiny { span, .. } => span.end_offset(),
+            PosImpl::Small { end, .. } => end.offset() as usize,
+            PosImpl::Large { end, .. } => end.offset() as usize,
+            PosImpl::Tiny { span, .. } => span.end_offset() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
         }
     }
 
     pub fn start_offset(&self) -> usize {
         match &self.0 {
-            PosImpl::Small { start, .. } => start.offset(),
-            PosImpl::Large { start, .. } => start.offset(),
-            PosImpl::Tiny { span, .. } => span.start_offset(),
+            PosImpl::Small { start, .. } => start.offset() as usize,
+            PosImpl::Large { start, .. } => start.offset() as usize,
+            PosImpl::Tiny { span, .. } => span.start_offset() as usize,
             PosImpl::FromReason(_p) => unimplemented!(),
         }
     }
@@ -497,6 +537,7 @@ impl EqModuloPos for Pos {
     }
 }
 
+#[cfg(not(target_arch = "wasm32"))]
 impl ToOcamlRep for PosImpl {
     fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, alloc: &'a A) -> ocamlrep::Value<'a> {
         match self {
@@ -530,6 +571,7 @@ impl ToOcamlRep for PosImpl {
     }
 }
 
+#[cfg(not(target_arch = "wasm32"))]
 impl FromOcamlRep for PosImpl {
     fn from_ocamlrep(value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError> {
         use ocamlrep::from;
@@ -652,22 +694,18 @@ mod tests {
     #[test]
     fn test_pos() {
         assert!(Pos::NONE.is_none());
-        assert!(
-            !Pos::from_lnum_bol_offset(
-                Arc::new(RelativePath::make(Prefix::Dummy, PathBuf::from("a"))),
-                (0, 0, 0),
-                (0, 0, 0)
-            )
-            .is_none(),
-        );
-        assert!(
-            !Pos::from_lnum_bol_offset(
-                Arc::new(RelativePath::make(Prefix::Dummy, PathBuf::from(""))),
-                (1, 0, 0),
-                (0, 0, 0)
-            )
-            .is_none(),
-        );
+        assert!(!Pos::from_lnum_bol_offset(
+            Arc::new(RelativePath::make(Prefix::Dummy, PathBuf::from("a"))),
+            (0, 0, 0),
+            (0, 0, 0)
+        )
+        .is_none(),);
+        assert!(!Pos::from_lnum_bol_offset(
+            Arc::new(RelativePath::make(Prefix::Dummy, PathBuf::from(""))),
+            (1, 0, 0),
+            (0, 0, 0)
+        )
+        .is_none(),);
     }
 
     #[test]
diff --git a/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs b/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
index b0c24a4c9f5..5e2c65f7532 100644
--- a/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
+++ b/hphp/hack/src/utils/rust/pos/pos_span_tiny.rs
@@ -130,83 +130,83 @@ impl PosSpanTiny {
         ))
     }
 
-    pub fn start_beginning_of_line(self) -> usize {
+    pub fn start_beginning_of_line(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
             mask_by(
                 START_BEGINNING_OF_LINE_BITS,
                 self.0 >> START_BEGINNING_OF_LINE_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    pub fn start_line_number(self) -> usize {
+    pub fn start_line_number(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
-            mask_by(START_LINE_NUMBER_BITS, self.0 >> START_LINE_NUMBER_OFFSET) as usize
+            mask_by(START_LINE_NUMBER_BITS, self.0 >> START_LINE_NUMBER_OFFSET)
         }
     }
 
-    pub fn start_column(self) -> usize {
+    pub fn start_column(self) -> u64 {
         if self.is_dummy() {
-            usize::MAX
+            u64::MAX
         } else {
             mask_by(
                 START_COLUMN_NUMBER_BITS,
                 self.0 >> START_COLUMN_NUMBER_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    fn beginning_of_line_increment(self) -> usize {
+    fn beginning_of_line_increment(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
             mask_by(
                 BEGINNING_OF_LINE_INCREMENT_BITS,
                 self.0 >> BEGINNING_OF_LINE_INCREMENT_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    fn line_number_increment(self) -> usize {
+    fn line_number_increment(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
             mask_by(
                 LINE_NUMBER_INCREMENT_BITS,
                 self.0 >> LINE_NUMBER_INCREMENT_OFFSET,
-            ) as usize
+            )
         }
     }
 
-    fn width(self) -> usize {
+    fn width(self) -> u64 {
         if self.is_dummy() {
             0
         } else {
-            mask_by(WIDTH_BITS, self.0 >> WIDTH_OFFSET) as usize
+            mask_by(WIDTH_BITS, self.0 >> WIDTH_OFFSET)
         }
     }
 
-    pub fn start_offset(self) -> usize {
+    pub fn start_offset(self) -> u64 {
         self.start_beginning_of_line() + self.start_column()
     }
 
-    pub fn end_line_number(self) -> usize {
+    pub fn end_line_number(self) -> u64 {
         self.start_line_number() + self.line_number_increment()
     }
 
-    pub fn end_beginning_of_line(self) -> usize {
+    pub fn end_beginning_of_line(self) -> u64 {
         self.start_beginning_of_line() + self.beginning_of_line_increment()
     }
 
-    pub fn end_offset(self) -> usize {
+    pub fn end_offset(self) -> u64 {
         self.start_offset() + self.width()
     }
 
-    pub fn end_column(self) -> usize {
+    pub fn end_column(self) -> u64 {
         self.end_offset() - self.end_beginning_of_line()
     }
 
@@ -221,8 +221,16 @@ impl PosSpanTiny {
             let end_bol = self.end_beginning_of_line();
             let end_offset = self.end_offset();
             PosSpanRaw {
-                start: FilePosLarge::from_lnum_bol_offset(start_lnum, start_bol, start_offset),
-                end: FilePosLarge::from_lnum_bol_offset(end_lnum, end_bol, end_offset),
+                start: FilePosLarge::from_lnum_bol_offset(
+                    start_lnum as u64,
+                    start_bol as u64,
+                    start_offset as u64,
+                ),
+                end: FilePosLarge::from_lnum_bol_offset(
+                    end_lnum as u64,
+                    end_bol as u64,
+                    end_offset as u64,
+                ),
             }
         }
     }
@@ -399,9 +407,9 @@ mod test {
         let start_offset = u64::max_value();
         let end_offset = u64::max_value();
         let start =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, start_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, start_offset);
         let end =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, end_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, end_offset);
         let span = PosSpanTiny::make_dummy();
         assert_eq!(line, span.start_line_number() as u64);
         assert_eq!(line, span.end_line_number() as u64);
@@ -427,9 +435,9 @@ mod test {
         let start_offset = max_int;
         let end_offset = max_int;
         let start =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, start_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, start_offset);
         let end =
-            FilePosLarge::from_lnum_bol_offset(line as usize, bol as usize, end_offset as usize);
+            FilePosLarge::from_lnum_bol_offset(line, bol, end_offset);
         match PosSpanTiny::make(&start, &end) {
             None => {
                 // expected
@@ -463,8 +471,8 @@ mod test {
         let bol = 1667611usize;
         let start_offset = 1667617usize;
         let end_offset = 1667673usize;
-        let start = FilePosLarge::from_lnum_bol_offset(line, bol, start_offset);
-        let end = FilePosLarge::from_lnum_bol_offset(line, bol, end_offset);
+        let start = FilePosLarge::from_lnum_bol_offset(line as u64, bol as u64, start_offset as u64);
+        let end = FilePosLarge::from_lnum_bol_offset(line as u64, bol as u64, end_offset as u64);
         let span = PosSpanTiny::make(&start, &end).unwrap();
 
         // Though the span fits nicely into 63-bits, the resulting value is > 2^62 -
diff --git a/hphp/hack/src/utils/rust/relative_path.rs b/hphp/hack/src/utils/rust/relative_path.rs
index d4123d7822f..5f2cfcb7d97 100644
--- a/hphp/hack/src/utils/rust/relative_path.rs
+++ b/hphp/hack/src/utils/rust/relative_path.rs
@@ -218,6 +218,7 @@ impl<'de> Deserialize<'de> for RelativePath {
     }
 }
 
+#[cfg(not(target_arch = "wasm32"))]
 impl ToOcamlRep for RelativePath {
     fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, alloc: &'a A) -> ocamlrep::Value<'a> {
         let mut block = alloc.block_with_size(2);
@@ -227,6 +228,7 @@ impl ToOcamlRep for RelativePath {
     }
 }
 
+#[cfg(not(target_arch = "wasm32"))]
 impl FromOcamlRep for RelativePath {
     fn from_ocamlrep(value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError> {
         let block = ocamlrep::from::expect_tuple(value, 2)?;
@@ -236,6 +238,20 @@ impl FromOcamlRep for RelativePath {
     }
 }
 
+#[cfg(target_arch = "wasm32")]
+impl ToOcamlRep for RelativePath {
+    fn to_ocamlrep<'a, A: ocamlrep::Allocator>(&'a self, _alloc: &'a A) -> ocamlrep::Value<'a> {
+        panic!("ToOcamlRep not supported on WASM")
+    }
+}
+
+#[cfg(target_arch = "wasm32")]
+impl FromOcamlRep for RelativePath {
+    fn from_ocamlrep(_value: ocamlrep::Value<'_>) -> Result<Self, ocamlrep::FromError> {
+        panic!("FromOcamlRep not supported on WASM")
+    }
+}
+
 pub type Map<T> = std::collections::BTreeMap<RelativePath, T>;
 
 pub mod map {
